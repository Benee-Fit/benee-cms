import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import * as https from 'node:https';

import { ENHANCED_GEMINI_PROMPT } from './gemini-prompt-enhanced';

// API Keys from environment variables
const PDFCO_API_KEY = process.env['PDF_UPLOAD_SECRET'];
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// Regular expression to extract JSON from code blocks in markdown, defined at module level for performance
const jsonBlockRegex = /```(?:json)?\s*([\s\S]*?)```/g;

/**
 * Type definitions for API responses and requests
 */

// Plan option total represents the premium total for a specific plan option
interface PlanOptionTotal {
  planOptionName: string;
  totalMonthlyPremium: number;
}

// Rate guarantee information with period and details
interface RateGuarantee {
  coverageType?: string;
  duration?: string;
  endDate?: string;
  period?: string;
  details?: string;
}

// Document metadata including client, carrier, dates, and totals
interface Metadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotal[];
  rateGuarantees?: RateGuarantee[];
}

// Benefit details for coverage entries, allowing for flexible key-value pairs
interface BenefitDetails {
  [key: string]: string | number | null | undefined | Record<string, unknown>;
}

// Coverage entry representing a single insurance coverage
interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName: string;
  premium: number;
  monthlyPremium: number;
  unitRate: number;
  unitRateBasis: string;
  volume: number;
  lives: number;
  benefitDetails: BenefitDetails;
}

// Plan notes for additional document information
interface PlanNote {
  note: string;
}

// Structure of the parsed response from Gemini API
interface GeminiParsedResponse {
  metadata?: Metadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

// Options for HTTPS requests
interface HttpsRequestOptions {
  hostname: string;
  path: string;
  method: string;
  headers: Record<string, string>;
}

// HTTPS response data structure
interface HttpsResponseData {
  statusCode?: number;
  data?: string;
  error?: string;
  presignedUrl?: string;
  url?: string;
  rawResponse?: string;
}

// Gemini API error response
interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

// Gemini API success response
interface GeminiSuccessResponse {
  candidates: {
    content: {
      parts: {
        text: string;
      }[];
    };
    finishReason: string;
    safetyRatings: {
      category: string;
      probability: string;
    }[];
  }[];
}

/**
 * Helper function to make HTTPS requests
 * @param options HTTPS request options
 * @param data Optional data to send in the request body
 * @returns Promise resolving to the response data
 */
async function makeHttpsRequest(options: HttpsRequestOptions, data?: string): Promise<HttpsResponseData> {
  return new Promise((resolve) => {
    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        resolve({
          statusCode: res.statusCode,
          data: responseData,
        });
      });
    });
    
    req.on('error', (error) => {
      resolve({ error: error.message });
    });
    
    if (data) {
      req.write(data);
    }
    
    req.end();
  });
}

/**
 * Extract JSON from a Gemini API response text, handling markdown code blocks
 * @param text The response text from Gemini API
 * @returns Parsed JSON object or null if parsing fails
 */
function extractJsonFromGeminiResponse(text: string): GeminiParsedResponse | null {
  try {
    // First try direct JSON parsing
    return JSON.parse(text) as GeminiParsedResponse;
  } catch {
    // Then look for JSON in markdown code blocks
    const matches = text.match(jsonBlockRegex);
    
    if (matches && matches.length > 0) {
      try {
        // Extract content from the first markdown code block
        const jsonContent = matches[0].replace(/```(?:json)?\s*|\s*```/g, '');
        return JSON.parse(jsonContent) as GeminiParsedResponse;
      } catch (jsonError) {
        console.error('Error parsing JSON from markdown code block:', jsonError);
        return null;
      }
    }
    
    return null;
  }
}

/**
 * Validates coverage entries to ensure they have all required fields
 * @param coverages Array of coverage entries to validate
 * @returns Object containing valid coverages and counts
 */
function validateCoverages(coverages: CoverageEntry[]): {
  validCoverages: CoverageEntry[];
  validCount: number;
  invalidCount: number;
} {
  const validCoverages: CoverageEntry[] = [];
  let invalidCount = 0;
  
  coverages.forEach((coverage) => {
    // Check for required fields
    if (
      coverage.coverageType &&
      coverage.carrierName &&
      typeof coverage.premium === 'number' &&
      typeof coverage.monthlyPremium === 'number' &&
      typeof coverage.unitRate === 'number' &&
      coverage.unitRateBasis &&
      typeof coverage.volume === 'number' &&
      typeof coverage.lives === 'number'
    ) {
      // Ensure benefitDetails exists
      if (!coverage.benefitDetails) {
        coverage.benefitDetails = {};
      }
      validCoverages.push(coverage);
    } else {
      invalidCount++;
    }
  });
  
  return {
    validCoverages,
    validCount: validCoverages.length,
    invalidCount,
  };
}

/**
 * Creates default coverage entries when no valid coverages are found
 * @param metadata Metadata from the Gemini API response
 * @returns Array containing a default coverage entry
 */
function createDefaultCoverages(metadata?: Metadata): CoverageEntry[] {
  const carrierName = metadata?.carrierName || 'Unknown Carrier';
  const planOptionName = metadata?.planOptionName || 'Default Plan';
  
  // Create a default coverage entry
  const defaultCoverage: CoverageEntry = {
    coverageType: 'Basic Life',
    carrierName,
    planOptionName,
    premium: 0,
    monthlyPremium: 0,
    unitRate: 0,
    unitRateBasis: 'per $1,000',
    volume: 0,
    lives: 1,
    benefitDetails: {},
  };
  
  return [defaultCoverage];
}

/**
 * Extracts text from a PDF document using PDF.co API
 * @param fileBuffer The PDF file buffer
 * @returns Promise resolving to the extracted text
 */
async function extractTextFromPdf(fileBuffer: Buffer): Promise<string> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF.co API key not provided');
  }
  
  // Step 1: Upload PDF to PDF.co
  const uploadOptions: HttpsRequestOptions = {
    hostname: 'api.pdf.co',
    path: '/v1/file/upload',
    method: 'POST',
    headers: {
      'x-api-key': PDFCO_API_KEY,
      'Content-Type': 'application/octet-stream',
    },
  };
  
  // Create a base64 string from the buffer
  const base64Data = fileBuffer.toString('base64');
  
  // Upload the file
  const uploadResponse = await makeHttpsRequest(uploadOptions, base64Data);
  
  if (uploadResponse.error || !uploadResponse.data) {
    throw new Error(`Error uploading PDF: ${uploadResponse.error || 'No response data'}`);
  }
  
  let uploadData;
  try {
    uploadData = JSON.parse(uploadResponse.data);
  } catch (error) {
    throw new Error(`Error parsing upload response: ${error instanceof Error ? error.message : String(error)}`);
  }
  
  if (!uploadData.url) {
    throw new Error('Invalid upload response from PDF.co');
  }
  
  // Step 2: Extract text from PDF
  const extractOptions: HttpsRequestOptions = {
    hostname: 'api.pdf.co',
    path: '/v1/pdf/convert/to/text',
    method: 'POST',
    headers: {
      'x-api-key': PDFCO_API_KEY,
      'Content-Type': 'application/json',
    },
  };
  
  const extractData = JSON.stringify({
    url: uploadData.url,
    inline: true,
    encrypt: false,
  });
  
  const extractResponse = await makeHttpsRequest(extractOptions, extractData);
  
  if (extractResponse.error || !extractResponse.data) {
    throw new Error(`Error extracting text from PDF: ${extractResponse.error || 'No response data'}`);
  }
  
  let extractedResult;
  try {
    extractedResult = JSON.parse(extractResponse.data);
  } catch (error) {
    throw new Error(`Error parsing extraction response: ${error instanceof Error ? error.message : String(error)}`);
  }
  
  if (!extractedResult.url) {
    throw new Error('Invalid extraction response from PDF.co');
  }
  
  // Step 3: Download the extracted text
  const downloadOptions: HttpsRequestOptions = {
    hostname: 'api.pdf.co',
    path: `/v1/file/download?url=${encodeURIComponent(extractedResult.url)}`,
    method: 'GET',
    headers: {
      'x-api-key': PDFCO_API_KEY,
    },
  };
  
  const downloadResponse = await makeHttpsRequest(downloadOptions);
  
  if (downloadResponse.error || !downloadResponse.data) {
    throw new Error(`Error downloading extracted text: ${downloadResponse.error || 'No response data'}`);
  }
  
  return downloadResponse.data;
}

/**
 * Structures data from extracted PDF text using Google Gemini API
 * @param extractedText Text extracted from the PDF
 * @returns Promise resolving to the structured data
 */
async function structureDataWithGemini(extractedText: string): Promise<GeminiParsedResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('Gemini API key not provided');
  }
  
  // Prepare the request for Gemini API
  const promptText = ENHANCED_GEMINI_PROMPT.replace('{{EXTRACTED_TEXT}}', extractedText);
  
  const apiUrl = 'generativelanguage.googleapis.com';
  const apiEndpoint = '/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent';
  
  const options: HttpsRequestOptions = {
    hostname: apiUrl,
    path: `${apiEndpoint}?key=${GEMINI_API_KEY}`,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
  };
  
  const requestData = JSON.stringify({
    contents: [
      {
        parts: [
          {
            text: promptText,
          },
        ],
      },
    ],
    generationConfig: {
      temperature: 0,
      maxOutputTokens: 58192,
      responseMimeType: 'text/plain',
    },
  });
  
  const response = await makeHttpsRequest(options, requestData);
  
  if (response.error || !response.data) {
    throw new Error(`Error from Gemini API: ${response.error || 'No response data'}`);
  }
  
  try {
    const parsedResponse = JSON.parse(response.data) as GeminiSuccessResponse | GeminiErrorResponse;
    
    // Check if it's an error response
    if ('error' in parsedResponse) {
      throw new Error(`Gemini API error: ${parsedResponse.error.message}`);
    }
    
    // Extract the response text from the successful response
    const responseText = parsedResponse.candidates[0].content.parts[0].text;
    
    // Extract structured JSON from the response
    const structuredData = extractJsonFromGeminiResponse(responseText);
    
    if (!structuredData) {
      throw new Error('Failed to extract structured JSON from Gemini response');
    }
    
    // Validate coverages
    if (structuredData.coverages) {
      const validationResult = validateCoverages(structuredData.coverages);
      structuredData.coverages = validationResult.validCoverages;
      
      // If no valid coverages were found, create a default coverage
      if (validationResult.validCount === 0) {
        structuredData.coverages = createDefaultCoverages(structuredData.metadata);
      }
    } else {
      // If no coverages were provided, create a default coverage
      structuredData.coverages = createDefaultCoverages(structuredData.metadata);
    }
    
    return structuredData;
  } catch (error) {
    throw new Error(`Error processing Gemini response: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Main handler for the POST request to process document
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // Check if the request is a FormData with a file
    const formData = await request.formData();
    const file = formData.get('file') as File | null;
    
    if (!file) {
      return NextResponse.json(
        { error: 'No file uploaded' },
        { status: 400 }
      );
    }
    
    // Read the file as a buffer
    const buffer = Buffer.from(await file.arrayBuffer());
    
    // Extract text from PDF
    const extractedText = await extractTextFromPdf(buffer);
    
    // Structure the extracted data with Gemini API
    const structuredData = await structureDataWithGemini(extractedText);
    
    // Return the structured data
    return NextResponse.json(structuredData);
  } catch (error) {
    console.error('Error processing document:', error);
    
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'An unknown error occurred' },
      { status: 500 }
    );
  }
}

// API Keys from environment variables
const PDFCO_API_KEY = process.env['PDF_UPLOAD_SECRET'];
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

/**
 * Type definitions for API responses
 */
interface PlanOptionTotal {
  planOptionName: string;
  totalMonthlyPremium: number;
}

interface RateGuarantee {
  coverageType?: string;
  duration?: string;
  endDate?: string;
  period?: string;
  details?: string;
}

interface Metadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotal[];
  rateGuarantees?: RateGuarantee[];
}

interface BenefitDetails {
  [key: string]: string | number | null | undefined | Record<string, unknown>;
  note?: string;
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName: string;
  premium: number;
  monthlyPremium: number;
  unitRate: number;
  unitRateBasis: string;
  volume: number;
  lives: number;
  benefitDetails: BenefitDetails;
}

interface PlanNote {
  note: string;
}

interface GeminiParsedResponse {
  metadata?: Metadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

type GeminiResponse = GeminiParsedResponse;

interface HttpsRequestOptions {
  hostname: string;
  path: string;
  method: string;
  headers: Record<string, string>;
}

interface HttpsResponseData {
  statusCode?: number;
  data?: string;
  error?: string;
  presignedUrl?: string;
  url?: string;
  rawResponse?: string;
  body?: any;
}

interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

interface GeminiSuccessResponse {
  candidates: {
    content: {
      parts: {
        text: string;
      }[];
    };
    finishReason: string;
    safetyRatings: {
      category: string;
      probability: string;
    }[];
  }[];
}

// API Keys from environment variables
const PDFCO_API_KEY = process.env['PDF_UPLOAD_SECRET'];
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

/**
 * Type definitions for API responses
 */
interface PlanOptionTotal {
  planOptionName: string;
  totalMonthlyPremium: number;
}

interface RateGuarantee {
  coverageType?: string;
  duration?: string;
  endDate?: string;
  period?: string;
  details?: string;
}

interface Metadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotal[];
  rateGuarantees?: RateGuarantee[];
}

interface BenefitDetails {
  [key: string]: any;
  note?: string;
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName: string;
  premium: number;
  monthlyPremium: number;
  unitRate: number;
  unitRateBasis: string;
  volume: number;
  lives: number;
  benefitDetails: BenefitDetails;
}

interface PlanNote {
  note: string;
}

interface GeminiParsedResponse {
  metadata?: Metadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

type GeminiResponse = GeminiParsedResponse;

interface HttpsRequestOptions {
  hostname: string;
  path: string;
  method: string;
  headers: Record<string, string>;
}

type HttpsResponseData = {
  statusCode?: number;
  data?: string;
  error?: string;
};

interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

interface GeminiSuccessResponse {
  candidates: {
    content: {
      parts: {
        text: string;
      }[];
    };
    finishReason: string;
    safetyRatings: {
      category: string;
      probability: string;
    }[];
  }[];
}

// API Keys from environment variables
const PDFCO_API_KEY = process.env['PDF_UPLOAD_SECRET'];
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

/**
 * Type definitions for the enhanced Gemini API response
 */
interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

interface GeminiSuccessResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
    finishReason: string;
    safetyRatings: Array<{
      category: string;
      probability: string;
    }>;
  }>;
}

interface PlanNote {
  note: string;
}

interface RateGuarantee {
  coverageType?: string;
  duration?: string;
  endDate?: string;
  [key: string]: string | undefined;
}

interface PlanOptionTotal {
  planOptionName: string;
  totalMonthlyPremium: number;
}

interface Metadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotal[];
  rateGuarantees?: RateGuarantee[];
  [key: string]: string | number | Array<any> | undefined;
}

interface BenefitDetails {
  [key: string]: string | number | null | undefined | Array<any> | Record<string, any>;
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName: string;
  premium: number;
  monthlyPremium: number;
  unitRate: number;
  unitRateBasis: string;
  volume: number;
  lives: number;
  benefitDetails: BenefitDetails;
}

interface GeminiParsedResponse {
  metadata?: Metadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

interface HttpsRequestOptions {
  hostname: string;
  path: string;
  method: string;
  headers: Record<string, string>;
}

type HttpsResponseData = Record<string, any>;

/**
 * Helper function to make HTTPS requests
 * @param options HTTPS request options
 * @param data Optional data to send in the request body
 * @returns Promise resolving to the response data
 */
async function makeHttpsRequest(options: HttpsRequestOptions, data?: string): Promise<HttpsResponseData> {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let responseData = '';
      
      res.on('data', (chunk) => {
        responseData += chunk;
      });
      
      res.on('end', () => {
        try {
          // Parse the response data as JSON
          const parsedData = JSON.parse(responseData);
          resolve(parsedData);
        } catch (error) {
          // If JSON parsing fails, return the raw response
          resolve({ rawResponse: responseData });
        }
      });
    });
    
    req.on('error', (error) => {
      reject(error);
    });
    
    if (data) {
      req.write(data);
    }
    
    req.end();
  });
}

/**
 * Extract JSON from a Gemini API response text, handling markdown code blocks
 * @param text The response text from Gemini API
 * @returns Parsed JSON object or null if parsing fails
 */
function extractJsonFromGeminiResponse(text: string): GeminiParsedResponse | null {
  // Regular expression to match JSON content within markdown code blocks
  const jsonBlockRegex = /```(?:json)?\s*([\s\S]*?)```/;
  
  try {
    // Check if the response contains a JSON code block
    const match = text.match(jsonBlockRegex);
    
    if (match && match[1]) {
      // Extract JSON from the code block
      return JSON.parse(match[1].trim());
    }
    
    // If no code block is found, try parsing the entire text as JSON
    return JSON.parse(text.trim());
  } catch (error) {
    // Return null if JSON parsing fails
    return null;
  }
}

/**
 * Validates coverage entries to ensure they have all required fields
 * @param coverages Array of coverage entries to validate
 * @returns Object containing valid coverages and counts
 */
function validateCoverages(coverages: CoverageEntry[]): { validCoverages: CoverageEntry[]; validCount: number; invalidCount: number } {
  if (!coverages || !Array.isArray(coverages)) {
    return { validCoverages: [], validCount: 0, invalidCount: 0 };
  }
  
  const validCoverages: CoverageEntry[] = [];
  let invalidCount = 0;
  
  for (const coverage of coverages) {
    // Validate required fields
    if (
      typeof coverage.coverageType === 'string' &&
      typeof coverage.carrierName === 'string' &&
      typeof coverage.planOptionName === 'string' &&
      coverage.benefitDetails !== undefined
    ) {
      // Ensure numeric fields have valid values or defaults
      const validatedCoverage: CoverageEntry = {
        coverageType: coverage.coverageType,
        carrierName: coverage.carrierName,
        planOptionName: coverage.planOptionName,
        premium: typeof coverage.premium === 'number' ? coverage.premium : 0,
        monthlyPremium: typeof coverage.monthlyPremium === 'number' ? coverage.monthlyPremium : 0,
        unitRate: typeof coverage.unitRate === 'number' ? coverage.unitRate : 0,
        unitRateBasis: typeof coverage.unitRateBasis === 'string' ? coverage.unitRateBasis : 'per $1,000',
        volume: typeof coverage.volume === 'number' ? coverage.volume : 0,
        lives: typeof coverage.lives === 'number' ? coverage.lives : 0,
        benefitDetails: coverage.benefitDetails || {}
      };
      
      validCoverages.push(validatedCoverage);
    } else {
      invalidCount++;
    }
  }
  
  return {
    validCoverages,
    validCount: validCoverages.length,
    invalidCount
  };
}

/**
 * Creates default coverage entries when no valid coverages are found
 * @param metadata Metadata from the Gemini API response
 * @returns Array containing a default coverage entry
 */
function createDefaultCoverages(metadata?: Metadata): CoverageEntry[] {
  // Create a default coverage entry
  const defaultCoverage: CoverageEntry = {
    coverageType: 'Basic Life',
    carrierName: metadata?.carrierName || 'Unknown Carrier',
    planOptionName: metadata?.planOptionName || 'Default Plan',
    premium: 0,
    monthlyPremium: 0,
    unitRate: 0,
    unitRateBasis: 'per $1,000',
    volume: 0,
    lives: 0,
    benefitDetails: {
      note: 'Coverage details could not be extracted from document'
    }
  };
  
  return [defaultCoverage];
}

/**
 * Extracts text from a PDF document using PDF.co API
 * @param fileBuffer The PDF file buffer
 * @returns Promise resolving to the extracted text
 */
async function extractTextFromPdf(fileBuffer: Buffer): Promise<string> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF.co API key is not configured');
  }
  
  try {
    // Step 1: Get a presigned upload URL from PDF.co
    const uploadUrlOptions: HttpsRequestOptions = {
      hostname: 'api.pdf.co',
      path: `/v1/file/upload/get-presigned-url?name=document.pdf&contenttype=application/pdf`,
      method: 'GET',
      headers: {
        'x-api-key': PDFCO_API_KEY,
      },
    };
    
    const uploadUrlResponse = await makeHttpsRequest(uploadUrlOptions);
    
    if (!uploadUrlResponse.presignedUrl || !uploadUrlResponse.url) {
      throw new Error('Failed to get presigned upload URL');
    }
    
    // Step 2: Upload the file to the presigned URL
    const uploadOptions: HttpsRequestOptions = {
      hostname: new URL(uploadUrlResponse.presignedUrl).hostname,
      path: new URL(uploadUrlResponse.presignedUrl).pathname + new URL(uploadUrlResponse.presignedUrl).search,
      method: 'PUT',
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Length': fileBuffer.length.toString(),
      },
    };
    
    await makeHttpsRequest(uploadOptions, fileBuffer.toString('binary'));
    
    // Step 3: Process the uploaded file with PDF.co's PDF to Text API
    const processOptions: HttpsRequestOptions = {
      hostname: 'api.pdf.co',
      path: '/v1/pdf/convert/to/text',
      method: 'POST',
      headers: {
        'x-api-key': PDFCO_API_KEY,
        'Content-Type': 'application/json',
      },
    };
    
    const processData = JSON.stringify({
      url: uploadUrlResponse.url,
      inline: true,
      async: false,
    });
    
    const processResponse = await makeHttpsRequest(processOptions, processData);
    
    if (processResponse.error) {
      throw new Error(`PDF.co processing error: ${processResponse.error.message || 'Unknown error'}`);
    }
    
    if (!processResponse.url) {
      throw new Error('No text extraction URL provided in the response');
    }
    
    // Step 4: Download the extracted text
    const textUrl = new URL(processResponse.url);
    const downloadOptions: HttpsRequestOptions = {
      hostname: textUrl.hostname,
      path: textUrl.pathname + textUrl.search,
      method: 'GET',
      headers: {},
    };
    
    const textResponse = await makeHttpsRequest(downloadOptions);
    
    // Return the extracted text
    return textResponse.rawResponse || '';
  } catch (error) {
    throw new Error(`PDF text extraction failed: ${(error as Error).message}`);
  }
}

/**
 * Structures data from extracted PDF text using Google Gemini API
 * @param extractedText Text extracted from the PDF
 * @returns Promise resolving to the structured data
 */
async function structureDataWithGemini(extractedText: string): Promise<GeminiParsedResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('Gemini API key is not configured');
  }
  
  try {
    // Construct the request to the Gemini API
    const requestBody = JSON.stringify({
      contents: [
        {
          parts: [
            { text: `${ENHANCED_GEMINI_PROMPT}\n\nEXTRACTED TEXT FROM DOCUMENT:\n${extractedText}` }
          ]
        }
      ],
      generationConfig: {
        temperature: 0.2,
        topP: 0.8,
        topK: 40,
        maxOutputTokens: 58192,
        responseMimeType: "text/plain",
      },
    });
    
    const options: HttpsRequestOptions = {
      hostname: 'generativelanguage.googleapis.com',
      path: `/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent?key=${GEMINI_API_KEY}`,
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(requestBody),
      },
    };
    
    // Make the request to the Gemini API
    const response = await makeHttpsRequest(options, requestBody);
    
    // Check for error response from Gemini
    if ((response as GeminiErrorResponse).error) {
      const errorResponse = response as GeminiErrorResponse;
      throw new Error(`Gemini API error: ${errorResponse.error.message}`);
    }
    
    // Process successful response
    const successResponse = response as GeminiSuccessResponse;
    
    if (
      !successResponse.candidates ||
      !successResponse.candidates[0] ||
      !successResponse.candidates[0].content ||
      !successResponse.candidates[0].content.parts ||
      !successResponse.candidates[0].content.parts[0] ||
      typeof successResponse.candidates[0].content.parts[0].text !== 'string'
    ) {
      throw new Error('Invalid response format from Gemini API');
    }
    
    // Extract the text response
    const textResponse = successResponse.candidates[0].content.parts[0].text;
    
    // Extract and parse the JSON from the response
    const parsedJson = extractJsonFromGeminiResponse(textResponse);
    
    if (!parsedJson) {
      throw new Error('Failed to extract valid JSON from the Gemini API response');
    }
    
    // Validate the response structure
    const validatedResponse: GeminiParsedResponse = {
      metadata: parsedJson.metadata || {},
      coverages: [],
      planNotes: parsedJson.planNotes || [],
    };
    
    // Validate and filter coverages
    if (parsedJson.coverages && Array.isArray(parsedJson.coverages)) {
      const { validCoverages, validCount, invalidCount } = validateCoverages(parsedJson.coverages);
      validatedResponse.coverages = validCoverages;
      
      // If no valid coverages were found, add a default coverage
      if (validCount === 0) {
        validatedResponse.coverages = createDefaultCoverages(validatedResponse.metadata);
      }
    } else {
      // No coverages in the response, add default
      validatedResponse.coverages = createDefaultCoverages(validatedResponse.metadata);
    }
    
    return validatedResponse;
  } catch (error) {
    // Return a basic structure with default coverage if processing fails
    return {
      metadata: { carrierName: 'Unknown Carrier', planOptionName: 'Unknown Plan' },
      coverages: createDefaultCoverages({ carrierName: 'Unknown Carrier', planOptionName: 'Unknown Plan' }),
      planNotes: [{ note: `Processing error: ${(error as Error).message}` }],
    };
  }
}

/**
 * Main handler for the POST request to process document
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    // Get the form data from the request
    const formData = await request.formData();
    
    // Get the uploaded file from the form data
    const file = formData.get('file');
    
    // Validate that the file exists and is a PDF
    if (!file || !(file instanceof File)) {
      return NextResponse.json(
        { error: 'No file uploaded' },
        { status: 400 }
      );
    }
    
    // Check if the file is a PDF
    if (!file.name.toLowerCase().endsWith('.pdf')) {
      return NextResponse.json(
        { error: 'Uploaded file must be a PDF' },
        { status: 400 }
      );
    }
    
    // Convert the file to a buffer
    const fileBuffer = Buffer.from(await file.arrayBuffer());
    
    // Extract text from the PDF using PDF.co
    const extractedText = await extractTextFromPdf(fileBuffer);
    
    if (!extractedText || extractedText.trim().length === 0) {
      return NextResponse.json(
        { error: 'Failed to extract text from PDF' },
        { status: 400 }
      );
    }
    
    // Process the extracted text with Gemini API
    const structuredData = await structureDataWithGemini(extractedText);
    
    // Return the structured data
    return NextResponse.json(structuredData);
  } catch (error) {
    // Handle any errors
    return NextResponse.json(
      { error: `Document processing error: ${(error as Error).message}` },
      { status: 500 }
    );
  }
}

/**
 * Type definitions for the enhanced Gemini API response
 */
interface PlanOptionTotals {
  totalMonthlyPremium?: number;
  totalAnnualPremium?: number;
  totalEmployerMonthlyContribution?: number;
  totalEmployeeMonthlyContribution?: number;
}

interface RateGuarantee {
  coverageType?: string;
  period?: string;
  details?: string;
}

interface GeminiMetadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotals;
  rateGuarantees?: RateGuarantee[];
}

interface BenefitDetails {
  note?: string;
  [key: string]: unknown;
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName?: string;
  premium?: number;
  monthlyPremium?: number;
  unitRate?: number;
  unitRateBasis?: string;
  volume?: number;
  lives?: number;
  benefitDetails: BenefitDetails;
}

interface PlanNote {
  note: string;
}

interface GeminiResponse {
  metadata?: GeminiMetadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

// HTTP response types
type HttpsResponseData = Record<string, unknown>;

interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

interface GeminiSuccessResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
}

/**
 * Helper function to make HTTPS requests
 * @param options Request options
 * @param postData Data to send in POST request
 * @returns Promise with response data
 */
async function makeHttpsRequest(
  options: https.RequestOptions,
  postData?: string
): Promise<HttpsResponseData> {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        try {
          const parsedData = JSON.parse(data);
          resolve(parsedData);
        } catch (error) {
          reject(new Error(`Error parsing response: ${error instanceof Error ? error.message : String(error)}\nResponse data: ${data}`));
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    if (postData) {
      req.write(postData);
    }
    
    req.end();
  });
}

// Define the regex at the module level to avoid performance issues
const jsonBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/;

/**
 * Extract JSON content from model response text
 * @param text Response text that may contain markdown code blocks
 * @returns Parsed JSON object
 */
function extractJsonFromText(text: string): unknown {
  // Check if the text is wrapped in a markdown code block
  const match = text.match(jsonBlockRegex);
  
  const jsonContent = match ? match[1] : text;
  
  try {
    return JSON.parse(jsonContent);
  } catch (error) {
    throw new Error(`Failed to parse JSON: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Create a default coverage entry
 * @param metadata Metadata to use for defaults
 * @returns Default coverage entry
 */
function createDefaultCoverage(metadata?: GeminiMetadata): CoverageEntry {
  return {
    coverageType: 'Basic Life',
    carrierName: metadata?.carrierName || 'Unknown Carrier',
    planOptionName: metadata?.planOptionName || 'Default Plan',
    premium: 0,
    monthlyPremium: 0,
    unitRate: 0,
    unitRateBasis: 'per $1,000',
    volume: 0,
    lives: 0,
    benefitDetails: {
      note: 'Coverage details could not be extracted from document'
    }
  };
}

/**
 * Validates if a coverage entry has required fields
 * @param coverage Coverage entry to validate
 * @returns Whether the coverage is valid
 */
function isCoverageValid(coverage: CoverageEntry): boolean {
  return (
    typeof coverage === 'object' &&
    coverage !== null &&
    typeof coverage.coverageType === 'string' &&
    typeof coverage.carrierName === 'string' &&
    typeof coverage.benefitDetails === 'object' &&
    coverage.benefitDetails !== null
  );
}

/**
 * Validates and normalizes coverage entries
 * @param coverages Array of coverage entries to validate
 * @returns Object with valid coverages and validation statistics
 */
function validateCoverages(coverages: CoverageEntry[]): {
  validCoverages: CoverageEntry[];
  validCount: number;
  invalidCount: number;
} {
  if (!Array.isArray(coverages)) {
    return { validCoverages: [], validCount: 0, invalidCount: 0 };
  }

  const validCoverages: CoverageEntry[] = [];
  let validCount = 0;
  let invalidCount = 0;

  for (const coverage of coverages) {
    if (isCoverageValid(coverage)) {
      validCoverages.push(coverage);
      validCount++;
    } else {
      invalidCount++;
    }
  }

  return { validCoverages, validCount, invalidCount };
}

/**
 * Ensures there is at least one coverage in the response
 * @param response The validated Gemini response
 * @returns The response with at least one coverage
 */
function ensureCoverageExists(response: GeminiResponse): GeminiResponse {
  if (!response.coverages || response.coverages.length === 0) {
    const defaultCoverage = createDefaultCoverage(response.metadata);
    response.coverages = [defaultCoverage];
  }
  return response;
}

/**
 * Structure data using Gemini API
 * @param extractedText Text extracted from document
 * @returns Structured data from Gemini
 */
async function structureDataWithGemini(extractedText: string): Promise<GeminiResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY is not set');
  }
  
  const options: https.RequestOptions = {
    hostname: 'generativelanguage.googleapis.com',
    path: `/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent?key=${GEMINI_API_KEY}`,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    }
  };

  const prompt = ENHANCED_GEMINI_PROMPT.replace('{{DOCUMENT_TEXT}}', extractedText);

  const requestData = JSON.stringify({
    contents: [
      {
        parts: [
          {
            text: prompt
          }
        ]
      }
    ],
    generationConfig: {
      maxOutputTokens: 58192,
      responseMimeType: "text/plain"
    }
  });

  try {
    const response = await makeHttpsRequest(options, requestData);
    
    // Handle potential error response
    const errorResponse = response as GeminiErrorResponse;
    if (errorResponse.error) {
      throw new Error(`Gemini API Error: ${JSON.stringify(errorResponse.error)}`);
    }
    
    // Handle success response
    const successResponse = response as GeminiSuccessResponse;
    if (!successResponse.candidates || successResponse.candidates.length === 0) {
      throw new Error('No candidates in Gemini API response');
    }
    
    const textContent = successResponse.candidates[0]?.content?.parts[0]?.text;
    if (!textContent) {
      throw new Error('No text content in Gemini API response');
    }
    
    try {
      // Check if response is wrapped in markdown code block and extract the JSON
      const parsedJson = extractJsonFromText(textContent) as GeminiResponse;
      
      // Validate top-level structure
      const validatedResponse: GeminiResponse = {
        metadata: parsedJson.metadata || {},
        coverages: Array.isArray(parsedJson.coverages) ? parsedJson.coverages : [],
        planNotes: Array.isArray(parsedJson.planNotes) ? parsedJson.planNotes : []
      };
      
      // Validate coverages
      if (validatedResponse.coverages && validatedResponse.coverages.length > 0) {
        // Validate and filter coverages
        const { validCoverages, validCount, invalidCount } = validateCoverages(validatedResponse.coverages);
        
        if (invalidCount > 0) {
          // Replace with only valid coverages
          validatedResponse.coverages = validCoverages;
          
          if (validCount === 0) {
            // No valid coverages, create a default one
            const defaultCoverage = createDefaultCoverage(validatedResponse.metadata);
            validatedResponse.coverages = [defaultCoverage];
          }
        } else {
          // Normalize existing coverages
          validatedResponse.coverages = validatedResponse.coverages.map(coverage => {
            // Ensure benefitDetails exists
            if (!coverage.benefitDetails || typeof coverage.benefitDetails !== 'object') {
              coverage.benefitDetails = { note: 'No benefit details available' };
            }
            return coverage;
          });
        }
      } else {
        // No coverages, create a default one
        const defaultCoverage = createDefaultCoverage(validatedResponse.metadata);
        validatedResponse.coverages = [defaultCoverage];
      }
      
      // Ensure there's at least one coverage entry
      return ensureCoverageExists(validatedResponse);
      
    } catch (jsonError) {
      const errorMessage = jsonError instanceof Error ? jsonError.message : String(jsonError);
      throw new Error(`Failed to parse Gemini response as JSON: ${textContent.substring(0, 200)}...\nError: ${errorMessage}`);
    }
  } catch (error) {
    // Safely handle error messages regardless of error object structure
    const errorMessage = error instanceof Error ? error.message : 
      typeof error === 'object' && error !== null && 'message' in error ? String(error.message) : 
      String(error);
    
    // Return default structure on error
    const defaultResponse: GeminiResponse = {
      metadata: {
        documentType: 'Insurance Document',
        carrierName: 'Unknown Carrier',
        planOptionName: 'Default Plan'
      },
      coverages: [createDefaultCoverage()],
      planNotes: [{ note: `Error processing document: ${errorMessage}` }]
    };
    
    return defaultResponse;
  }
}

/**
 * Extract text from PDF using PDF.co API
 * @param fileBuffer PDF file buffer
 * @returns Extracted text
 */
async function extractTextFromPdf(fileBuffer: Buffer): Promise<string> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF_UPLOAD_SECRET is not set');
  }
  
  // Step 1: Get a presigned URL to upload the file
  const presignedUrlOptions: https.RequestOptions = {
    hostname: 'api.pdf.co',
    path: `/v1/file/upload/get-presigned-url?name=${encodeURIComponent('document.pdf')}&contenttype=application/pdf`,
    method: 'GET',
    headers: {
      'x-api-key': PDFCO_API_KEY
    }
  };
  
  const presignedUrlResponse = await makeHttpsRequest(presignedUrlOptions);
  if (!presignedUrlResponse.presignedUrl || !presignedUrlResponse.url) {
    throw new Error('Failed to get presigned URL from PDF.co');
  }
  
  // Step 2: Upload the file to the presigned URL
  const presignedUrl = presignedUrlResponse.presignedUrl as string;
  const fileUrl = presignedUrlResponse.url as string;
  
  const uploadOptions: https.RequestOptions = {
    method: 'PUT',
    headers: {
      'Content-Type': 'application/pdf',
      'Content-Length': fileBuffer.length.toString()
    }
  };
  
  // Parse URL to get hostname and path for the request
  const uploadUrl = new URL(presignedUrl);
  uploadOptions.hostname = uploadUrl.hostname;
  uploadOptions.path = uploadUrl.pathname + uploadUrl.search;
  
  await makeHttpsRequest(uploadOptions, fileBuffer.toString('binary'));
  
  // Step 3: Extract text from the uploaded PDF
  const extractOptions: https.RequestOptions = {
    hostname: 'api.pdf.co',
    path: '/v1/pdf/convert/to/text',
    method: 'POST',
    headers: {
      'x-api-key': PDFCO_API_KEY,
      'Content-Type': 'application/json'
    }
  };
  
  const extractRequestData = JSON.stringify({
    url: fileUrl,
    inline: true,
    async: false
  });
  
  const extractResponse = await makeHttpsRequest(extractOptions, extractRequestData);
  
  if (extractResponse.error) {
    throw new Error(`PDF.co API Error: ${JSON.stringify(extractResponse.error)}`);
  }
  
  if (!extractResponse.body) {
    throw new Error('No text content in PDF.co response');
  }
  
  return extractResponse.body as string;
}

/**
 * Process a document to extract and structure its data
 * @param formData Form data with file
 * @returns Structured data from document
 */
async function processDocument(formData: FormData): Promise<GeminiResponse> {
  // Get the uploaded file from form data
  const file = formData.get('file') as File;
  
  if (!file || !(file instanceof File)) {
    throw new Error('No file uploaded');
  }
  
  // Check file type
  if (file.type !== 'application/pdf') {
    throw new Error('Only PDF files are supported');
  }
  
  // Convert file to buffer
  const buffer = Buffer.from(await file.arrayBuffer());
  
  // Extract text from PDF
  const extractedText = await extractTextFromPdf(buffer);
  
  if (!extractedText || extractedText.trim() === '') {
    throw new Error('No text could be extracted from the PDF');
  }
  
  // Process the extracted text with Gemini API
  return await structureDataWithGemini(extractedText);
}

/**
 * API route handler
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const formData = await request.formData();
    const result = await processDocument(formData);
    
    return NextResponse.json(result, { status: 200 });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    
    return NextResponse.json(
      { error: errorMessage },
      { status: 500 }
    );
  }
}

// Import the enhanced Gemini prompt
import { ENHANCED_GEMINI_PROMPT } from './gemini-prompt-enhanced';

// API Keys from environment variables
const PDFCO_API_KEY = process.env['PDF_UPLOAD_SECRET'];
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

/**
 * Type definitions for the enhanced Gemini API response
 */
interface PlanOptionTotals {
  totalMonthlyPremium?: number;
  totalAnnualPremium?: number;
  totalEmployerMonthlyContribution?: number;
  totalEmployeeMonthlyContribution?: number;
}

interface RateGuarantee {
  coverageType?: string;
  period?: string;
  details?: string;
}

interface GeminiMetadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotals;
  rateGuarantees?: RateGuarantee[];
}

interface BenefitDetails {
  note?: string;
  [key: string]: unknown;
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName?: string;
  premium?: number;
  monthlyPremium?: number;
  unitRate?: number;
  unitRateBasis?: string;
  volume?: number;
  lives?: number;
  benefitDetails: BenefitDetails;
}

interface PlanNote {
  note: string;
}

interface GeminiResponse {
  metadata?: GeminiMetadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

// HTTP response types
type HttpsResponseData = Record<string, unknown>;

interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

interface GeminiSuccessResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
}

// API Keys from environment variables
const PDFCO_API_KEY = process.env['PDF_UPLOAD_SECRET'];
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

/**
 * Type definitions for the enhanced Gemini API response
 */
interface PlanOptionTotals {
  totalMonthlyPremium?: number;
  totalAnnualPremium?: number;
  totalEmployerMonthlyContribution?: number;
  totalEmployeeMonthlyContribution?: number;
}

interface RateGuarantee {
  coverageType?: string;
  period?: string;
  details?: string;
}

interface GeminiMetadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotals;
  rateGuarantees?: RateGuarantee[];
}

interface BenefitDetails {
  note?: string;
  [key: string]: unknown;
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName?: string;
  premium?: number;
  monthlyPremium?: number;
  unitRate?: number;
  unitRateBasis?: string;
  volume?: number;
  lives?: number;
  benefitDetails: BenefitDetails;
}

interface PlanNote {
  note: string;
}

interface GeminiResponse {
  metadata?: GeminiMetadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

// HTTP response types
type HttpsResponseData = Record<string, unknown>;

interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

interface GeminiSuccessResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
}

// API Keys from environment variables
const PDFCO_API_KEY = process.env['PDF_UPLOAD_SECRET'];
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

/**
 * Type definitions for the enhanced Gemini API response
 */
interface PlanOptionTotals {
  totalMonthlyPremium?: number;
  totalAnnualPremium?: number;
  totalEmployerMonthlyContribution?: number;
  totalEmployeeMonthlyContribution?: number;
}

interface RateGuarantee {
  coverageType?: string;
  period?: string;
  details?: string;
}

interface GeminiMetadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotals;
  rateGuarantees?: RateGuarantee[];
}

interface BenefitDetails {
  note?: string;
  [key: string]: any; // Using any here to allow for dynamic properties
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName?: string;
  premium?: number;
  monthlyPremium?: number;
  unitRate?: number;
  unitRateBasis?: string;
  volume?: number;
  lives?: number;
  benefitDetails: BenefitDetails;
}

interface PlanNote {
  note: string;
}

interface GeminiResponse {
  metadata?: GeminiMetadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

// HTTP response types
type HttpsResponseData = Record<string, any>;  // Using any to allow for dynamic response properties

interface GeminiErrorResponse {
  error: {
    code: number;
    message: string;
    status: string;
  };
}

interface GeminiSuccessResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
    };
  }>;
}

/**
 * Helper function to make HTTPS requests
 * @param options Request options
 * @param postData Data to send in POST request
 * @returns Promise with response data
 */
async function makeHttpsRequest(
  options: https.RequestOptions,
  postData?: string
): Promise<HttpsResponseData> {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = '';
      res.on('data', (chunk) => {
        data += chunk;
      });

      res.on('end', () => {
        try {
          const parsedData = JSON.parse(data);
          resolve(parsedData);
        } catch (error) {
          reject(new Error(`Error parsing response: ${error instanceof Error ? error.message : String(error)}\nResponse data: ${data}`));
        }
      });
    });

    req.on('error', (error) => {
      reject(error);
    });

    if (postData) {
      req.write(postData);
    }
    
    req.end();
  });
}

// Define the regex at the module level to avoid performance issues
const jsonBlockRegex = /```(?:json)?\s*([\s\S]*?)\s*```/;

/**
 * Extract JSON content from model response text
 * @param text Response text that may contain markdown code blocks
 * @returns Parsed JSON object
 */
function extractJsonFromText(text: string): unknown {
  // Check if the text is wrapped in a markdown code block
  const match = text.match(jsonBlockRegex);
  
  const jsonContent = match ? match[1] : text;
  
  try {
    return JSON.parse(jsonContent);
  } catch (error) {
    throw new Error(`Failed to parse JSON: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Create a default coverage entry
 * @param metadata Metadata to use for defaults
 * @returns Default coverage entry
 */
function createDefaultCoverage(metadata?: GeminiMetadata): CoverageEntry {
  return {
    coverageType: 'Basic Life',
    carrierName: metadata?.carrierName || 'Unknown Carrier',
    planOptionName: metadata?.planOptionName || 'Default Plan',
    premium: 0,
    monthlyPremium: 0,
    unitRate: 0,
    unitRateBasis: 'per $1,000',
    volume: 0,
    lives: 0,
    benefitDetails: {
      note: 'Coverage details could not be extracted from document'
    }
  };
}

/**
 * Validates if a coverage entry has required fields
 * @param coverage Coverage entry to validate
 * @returns Whether the coverage is valid
 */
function isCoverageValid(coverage: CoverageEntry): boolean {
  return (
    typeof coverage === 'object' &&
    coverage !== null &&
    typeof coverage.coverageType === 'string' &&
    typeof coverage.carrierName === 'string' &&
    typeof coverage.benefitDetails === 'object' &&
    coverage.benefitDetails !== null
  );
}

/**
 * Validates and normalizes coverage entries
 * @param coverages Array of coverage entries to validate
 * @returns Object with valid coverages and validation statistics
 */
function validateCoverages(coverages: CoverageEntry[]): {
  validCoverages: CoverageEntry[];
  validCount: number;
  invalidCount: number;
} {
  if (!Array.isArray(coverages)) {
    return { validCoverages: [], validCount: 0, invalidCount: 0 };
  }

  const validCoverages: CoverageEntry[] = [];
  let validCount = 0;
  let invalidCount = 0;

  // Using for...of instead of forEach for better performance
  for (const coverage of coverages) {
    if (isCoverageValid(coverage)) {
      validCoverages.push(coverage);
      validCount++;
    } else {
      invalidCount++;
    }
  }

  return { validCoverages, validCount, invalidCount };
}

/**
 * Ensures there is at least one coverage in the response
 * @param response The validated Gemini response
 * @returns The response with at least one coverage
 */
function ensureCoverageExists(response: GeminiResponse): GeminiResponse {
  if (!response.coverages || response.coverages.length === 0) {
    const defaultCoverage = createDefaultCoverage(response.metadata);
    return {
      ...response,
      coverages: [defaultCoverage]
    };
  }
  return response;
}

/**
 * Structure data using Gemini API
 * @param extractedText Text extracted from document
 * @returns Structured data from Gemini
 */
async function structureDataWithGemini(extractedText: string): Promise<GeminiResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY environment variable not found');
  }
  
  // Set up Gemini API request
  const geminiEndpoint = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent';
  
  const options: https.RequestOptions = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
  };
  
  // Prepare prompt with extracted text
  const prompt = ENHANCED_GEMINI_PROMPT.replace('{DOCUMENT_TEXT}', extractedText);
  
  const postData = JSON.stringify({
    contents: [
      {
        parts: [
          {
            text: prompt,
          },
        ],
      },
    ],
    generationConfig: {
      temperature: 0.2,
      topP: 0.95,
      topK: 40,
      responseMimeType: 'text/plain',
      maxOutputTokens: 58192,
    },
  });
  
  try {
    // Add API key as query parameter
    const apiUrl = new URL(geminiEndpoint);
    apiUrl.searchParams.append('key', GEMINI_API_KEY);
    
    options.hostname = apiUrl.hostname;
    options.path = `${apiUrl.pathname}${apiUrl.search}`;
  
    // Make the request to Gemini API
    const response = await makeHttpsRequest(options, postData);
    
    // Check for errors in the API response
    if ('error' in response) {
      const errorResponse = response as unknown as GeminiErrorResponse;
      throw new Error(`Gemini API error: ${errorResponse.error.message}`);
    }
    
    // Process successful response
    const successResponse = response as unknown as GeminiSuccessResponse;
    if (!successResponse.candidates || successResponse.candidates.length === 0) {
      throw new Error('Empty response from Gemini API');
    }
    
    const responseText = successResponse.candidates[0]?.content?.parts[0]?.text;
    if (!responseText) {
      throw new Error('No text in Gemini API response');
    }
    
    // Extract and parse JSON from response text
    const parsedJson = extractJsonFromText(responseText) as GeminiResponse;
    
    // Validate the response structure
    if (!parsedJson || typeof parsedJson !== 'object') {
      throw new Error('Invalid JSON structure from Gemini API');
    }
    
    // Ensure we have a proper GeminiResponse structure
    const validatedResponse: GeminiResponse = {
      metadata: parsedJson.metadata || {},
      coverages: parsedJson.coverages || [],
      planNotes: parsedJson.planNotes || [],
    };
    
    // Validate coverages
    const { validCoverages } = validateCoverages(validatedResponse.coverages || []);
    
    // Update the response with validated coverages
    validatedResponse.coverages = validCoverages;
    
    // Ensure we have at least one coverage entry
    const finalResponse = ensureCoverageExists(validatedResponse);
    
    return finalResponse;
  } catch (error) {
    throw new Error(`Failed to structure data with Gemini: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Extract text from PDF using PDF.co API
 * @param fileBuffer PDF file buffer
 * @returns Extracted text
 */
async function extractTextFromPdf(fileBuffer: Buffer): Promise<string> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF_UPLOAD_SECRET environment variable not found');
  }

  const base64File = fileBuffer.toString('base64');
  
  const options: https.RequestOptions = {
    hostname: 'api.pdf.co',
    path: '/v1/pdf/extract/text',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': PDFCO_API_KEY,
    },
  };
  
  const postData = JSON.stringify({
    name: 'document.pdf',
    url: `data:application/pdf;base64,${base64File}`,
  });
  
  try {
    const response = await makeHttpsRequest(options, postData);
    
    if ('error' in response) {
      throw new Error(`PDF.co API error: ${String(response.error)}`);
    }
    
    if (!('url' in response) || !response.url) {
      throw new Error('No URL in PDF.co API response');
    }
    
    // Get the text from the URL
    const textUrlResponse = await fetch(response.url as string);
    if (!textUrlResponse.ok) {
      throw new Error(`Failed to fetch text from URL: ${textUrlResponse.statusText}`);
    }
    
    const extractedText = await textUrlResponse.text();
    return extractedText;
  } catch (error) {
    throw new Error(`Failed to extract text from PDF: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Process a document to extract and structure its data
 * @param formData Form data with file
 * @returns Structured data from document
 */
async function processDocument(formData: FormData): Promise<GeminiResponse> {
  const file = formData.get('file');
  
  if (!file || !(file instanceof File)) {
    throw new Error('No file found in request');
  }
  
  // Check file type
  if (!file.type.includes('pdf')) {
    throw new Error('Only PDF files are supported');
  }
  
  // Convert file to buffer
  const fileBuffer = await file.arrayBuffer().then(Buffer.from);
  
  // Extract text from PDF
  const extractedText = await extractTextFromPdf(fileBuffer);
  
  if (!extractedText || extractedText.trim().length === 0) {
    throw new Error('Could not extract text from PDF');
  }
  
  // Structure data with Gemini
  const structuredData = await structureDataWithGemini(extractedText);
  
  return structuredData;
}

/**
 * API route handler
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const formData = await request.formData();
    
    const result = await processDocument(formData);
    
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

/**
 * Structure data using Gemini API
 * @param extractedText Text extracted from document
 * @returns Structured data from Gemini
 */
async function structureDataWithGemini(extractedText: string): Promise<GeminiResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY environment variable not found');
  }
  
  // Set up Gemini API request
  const geminiEndpoint = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent';
  
  const options: https.RequestOptions = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
  };
  
  // Prepare prompt with extracted text
  const prompt = ENHANCED_GEMINI_PROMPT.replace('{DOCUMENT_TEXT}', extractedText);
  
  const postData = JSON.stringify({
    contents: [
      {
        parts: [
          {
            text: prompt,
          },
        ],
      },
    ],
    generationConfig: {
      temperature: 0.2,
      topP: 0.95,
      topK: 40,
      responseMimeType: 'text/plain',
      maxOutputTokens: 58192,
    },
  });
  
  try {
    // Add API key as query parameter
    const apiUrl = new URL(geminiEndpoint);
    apiUrl.searchParams.append('key', GEMINI_API_KEY);
    
    options.hostname = apiUrl.hostname;
    options.path = `${apiUrl.pathname}${apiUrl.search}`;
  
    // Make the request to Gemini API
    const response = await makeHttpsRequest(options, postData);
    
    // Check for errors in the API response
    if ('error' in response) {
      const errorResponse = response as unknown as GeminiErrorResponse;
      throw new Error(`Gemini API error: ${errorResponse.error.message}`);
    }
    
    // Process successful response
    const successResponse = response as unknown as GeminiSuccessResponse;
    if (!successResponse.candidates || successResponse.candidates.length === 0) {
      throw new Error('Empty response from Gemini API');
    }
    
    const responseText = successResponse.candidates[0]?.content?.parts[0]?.text;
    if (!responseText) {
      throw new Error('No text in Gemini API response');
    }
    
    // Extract and parse JSON from response text
    const parsedJson = extractJsonFromText(responseText) as GeminiResponse;
    
    // Validate the response structure
    if (!parsedJson || typeof parsedJson !== 'object') {
      throw new Error('Invalid JSON structure from Gemini API');
    }
    
    // Ensure we have a proper GeminiResponse structure
    const validatedResponse: GeminiResponse = {
      metadata: parsedJson.metadata || {},
      coverages: parsedJson.coverages || [],
      planNotes: parsedJson.planNotes || [],
    };
    
    // Validate coverages
    const { validCoverages, validCount, invalidCount } = validateCoverages(validatedResponse.coverages || []);
    
    // Update the response with validated coverages
    validatedResponse.coverages = validCoverages;
    
    // Ensure we have at least one coverage entry
    const finalResponse = ensureCoverageExists(validatedResponse);
    
    return finalResponse;
  } catch (error) {
    throw new Error(`Failed to structure data with Gemini: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Extract text from PDF using PDF.co API
 * @param fileBuffer PDF file buffer
 * @returns Extracted text
 */
async function extractTextFromPdf(fileBuffer: Buffer): Promise<string> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF_UPLOAD_SECRET environment variable not found');
  }

  const base64File = fileBuffer.toString('base64');
  
  const options: https.RequestOptions = {
    hostname: 'api.pdf.co',
    path: '/v1/pdf/extract/text',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': PDFCO_API_KEY,
    },
  };
  
  const postData = JSON.stringify({
    name: 'document.pdf',
    url: `data:application/pdf;base64,${base64File}`,
  });
  
  try {
    const response = await makeHttpsRequest(options, postData);
    
    if ('error' in response) {
      throw new Error(`PDF.co API error: ${String(response.error)}`);
    }
    
    if (!('url' in response) || !response.url) {
      throw new Error('No URL in PDF.co API response');
    }
    
    // Get the text from the URL
    const textUrlResponse = await fetch(response.url as string);
    if (!textUrlResponse.ok) {
      throw new Error(`Failed to fetch text from URL: ${textUrlResponse.statusText}`);
    }
    
    const extractedText = await textUrlResponse.text();
    return extractedText;
  } catch (error) {
    throw new Error(`Failed to extract text from PDF: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Process a document to extract and structure its data
 * @param formData Form data with file
 * @returns Structured data from document
 */
async function processDocument(formData: FormData): Promise<GeminiResponse> {
  const file = formData.get('file');
  
  if (!file || !(file instanceof File)) {
    throw new Error('No file found in request');
  }
  
  // Check file type
  if (!file.type.includes('pdf')) {
    throw new Error('Only PDF files are supported');
  }
  
  // Convert file to buffer
  const fileBuffer = await file.arrayBuffer().then(Buffer.from);
  
  // Extract text from PDF
  const extractedText = await extractTextFromPdf(fileBuffer);
  
  if (!extractedText || extractedText.trim().length === 0) {
    throw new Error('Could not extract text from PDF');
  }
  
  // Structure data with Gemini
  const structuredData = await structureDataWithGemini(extractedText);
  
  return structuredData;
}

/**
 * API route handler
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  try {
    const formData = await request.formData();
    
    const result = await processDocument(formData);
    
    return NextResponse.json({ success: true, data: result });
  } catch (error) {
    return NextResponse.json(
      { success: false, error: error instanceof Error ? error.message : String(error) },
      { status: 500 }
    );
  }
}

/**
 * Structure data using Gemini API
 * @param extractedText Text extracted from document
 * @returns Structured data from Gemini
 */
async function structureDataWithGemini(extractedText: string): Promise<GeminiResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY environment variable not found');
  }
  
  // Set up Gemini API request
  const geminiEndpoint = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent';
  
  const options: https.RequestOptions = {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
  };
  
  // Prepare prompt with extracted text
  const prompt = ENHANCED_GEMINI_PROMPT.replace('{DOCUMENT_TEXT}', extractedText);
  
  const postData = JSON.stringify({
    contents: [
      {
        parts: [
          {
            text: prompt,
          },
        ],
      },
    ],
    generationConfig: {
      temperature: 0.2,
      topP: 0.95,
      topK: 40,
      responseMimeType: 'text/plain',
      maxOutputTokens: 58192,
    },
  });
  
  try {
    // Add API key as query parameter
    const apiUrl = new URL(geminiEndpoint);
    apiUrl.searchParams.append('key', GEMINI_API_KEY);
    
    options.hostname = apiUrl.hostname;
    options.path = `${apiUrl.pathname}${apiUrl.search}`;
  
    // Make the request to Gemini API
    const response = await makeHttpsRequest(options, postData);
    
    // Check for errors in the API response
    const errorResponse = response as GeminiErrorResponse;
    if (errorResponse.error) {
      throw new Error(`Gemini API error: ${errorResponse.error.message}`);
    }
    
    // Process successful response
    const successResponse = response as GeminiSuccessResponse;
    if (!successResponse.candidates || successResponse.candidates.length === 0) {
      throw new Error('Empty response from Gemini API');
    }
    
    const responseText = successResponse.candidates[0]?.content?.parts[0]?.text;
    if (!responseText) {
      throw new Error('No text in Gemini API response');
    }
    
    // Extract and parse JSON from response text
    const parsedJson = extractJsonFromText(responseText) as GeminiResponse;
    
    // Validate the response structure
    if (!parsedJson || typeof parsedJson !== 'object') {
      throw new Error('Invalid JSON structure from Gemini API');
    }
    
    // Ensure we have a proper GeminiResponse structure
    const validatedResponse: GeminiResponse = {
      metadata: parsedJson.metadata || {},
      coverages: parsedJson.coverages || [],
      planNotes: parsedJson.planNotes || [],
    };
    
    // Validate coverages
    const { validCoverages, validCount, invalidCount } = validateCoverages(validatedResponse.coverages);
    
    // Update the response with validated coverages
    validatedResponse.coverages = validCoverages;
    
    // Ensure we have at least one coverage entry
    const finalResponse = ensureCoverageExists(validatedResponse);
    
    return finalResponse;
  } catch (error) {
    throw new Error(`Failed to structure data with Gemini: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Extract text from PDF using PDF.co API
 * @param fileBuffer PDF file buffer
 * @returns Extracted text
 */
async function extractTextFromPdf(fileBuffer: Buffer): Promise<string> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF_UPLOAD_SECRET environment variable not found');
  }

  const base64File = fileBuffer.toString('base64');
  
  const options: https.RequestOptions = {
    hostname: 'api.pdf.co',
    path: '/v1/pdf/extract/text',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': PDFCO_API_KEY,
    },
  };
  
  const postData = JSON.stringify({
    name: 'document.pdf',
    url: `data:application/pdf;base64,${base64File}`,
  });
  
  try {
    const response = await makeHttpsRequest(options, postData);
    
    if ('error' in response && response.error) {
      throw new Error(`PDF.co API error: ${String(response.error)}`);
    }
    
    if (!('url' in response) || !response.url) {
      throw new Error('No URL in PDF.co API response');
    }
    
    // Get the text from the URL
    const textUrlResponse = await fetch(response.url as string);
    if (!textUrlResponse.ok) {
      throw new Error(`Failed to fetch text from URL: ${textUrlResponse.statusText}`);
    }
    
    const extractedText = await textUrlResponse.text();
    return extractedText;
  } catch (error) {
    throw new Error(`Failed to extract text from PDF: ${error instanceof Error ? error.message : String(error)}`);
  }
}

/**
 * Helper function to make a Promise-based HTTPS request
 */
function httpsRequest(options: https.RequestOptions, postData?: string): Promise<HttpsResponse> {
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      let data = '';
      
      res.on('data', (chunk) => {
        data += chunk;
      });
      
      res.on('end', () => {
        try {
          if (res.statusCode && res.statusCode >= 200 && res.statusCode < 300) {
            const parsedData = JSON.parse(data);
            resolve(parsedData);
          } else {
            reject(new Error(`HTTP Error: ${res.statusCode} ${data}`));
          }
        } catch (error) {
          reject(new Error(`Error parsing response: ${error instanceof Error ? error.message : String(error)}`));
        }
      });
    });
    
    req.on('error', (error) => {
      reject(error);
    });
    
    if (postData) {
      req.write(postData);
    }
    
    req.end();
  });
}

/**
 * Get a presigned URL from PDF.co API to upload a file
 */
async function getPresignedUrl(fileName: string): Promise<{ presignedUrl: string, url: string }> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF.co API key not configured in environment variables');
  }
  
  const options = {
    hostname: 'api.pdf.co',
    path: `/v1/file/upload/get-presigned-url?contenttype=application/octet-stream&name=${encodeURIComponent(fileName)}`,
    method: 'GET',
    headers: {
      'x-api-key': PDFCO_API_KEY
    }
  };
  
  const response = await httpsRequest(options);
  
  if (response.error) {
    throw new Error(`PDF.co Error: ${response.message}`);
  }
  
  return {
    presignedUrl: response.presignedUrl,
    url: response.url
  };
}

/**
 * Upload a file to PDF.co's presigned URL
 */
async function uploadFileToPdfCo(presignedUrl: string, fileBuffer: Buffer): Promise<void> {
  const parsedUrl = new URL(presignedUrl);
  
  const options = {
    hostname: parsedUrl.hostname,
    path: parsedUrl.pathname + parsedUrl.search,
    method: 'PUT',
    headers: {
      'Content-Type': 'application/octet-stream',
      'Content-Length': fileBuffer.length
    }
  };
  
  return new Promise((resolve, reject) => {
    const req = https.request(options, (res) => {
      if (res.statusCode === 200) {
        resolve();
      } else {
        let errorData = '';
        res.on('data', (chunk) => { errorData += chunk; });
        res.on('end', () => {
          reject(new Error(`Upload failed: ${res.statusCode} ${errorData}`));
        });
      }
    });
    
    req.on('error', reject);
    req.write(fileBuffer);
    req.end();
  });
}

/**
 * Extract text from a PDF file using PDF.co API
 */
async function extractTextFromPdf(fileUrl: string): Promise<string> {
  if (!PDFCO_API_KEY) {
    throw new Error('PDF.co API key not configured in environment variables');
  }
  
  const options = {
    hostname: 'api.pdf.co',
    path: '/v1/pdf/convert/to/text',
    method: 'POST',
    headers: {
      'x-api-key': PDFCO_API_KEY,
      'Content-Type': 'application/json'
    }
  };
  
  const postData = JSON.stringify({
    url: fileUrl,
    inline: true,
    async: false
  });
  
  const response = await httpsRequest(options, postData);
  
  if (response.error) {
    throw new Error(`PDF.co Text Extraction Error: ${response.message}`);
  }
  
  return response.body || '';
}

/**
 * Type definitions for the enhanced Gemini API response
 */
interface PlanOptionTotals {
  totalMonthlyPremium?: number;
  totalAnnualPremium?: number;
  totalEmployerMonthlyContribution?: number;
  totalEmployeeMonthlyContribution?: number;
}

interface RateGuarantee {
  coverageType?: string;
  period?: string;
  details?: string;
}

interface GeminiMetadata {
  documentType?: string;
  clientName?: string;
  carrierName?: string;
  effectiveDate?: string;
  quoteDate?: string;
  policyNumber?: string;
  planOptionName?: string;
  totalProposedMonthlyPlanPremium?: number;
  planOptionTotals?: PlanOptionTotals;
  rateGuarantees?: RateGuarantee[];
}

interface BenefitDetails {
  [key: string]: any;
}

interface CoverageEntry {
  coverageType: string;
  carrierName: string;
  planOptionName?: string;
  premium?: number;
  monthlyPremium?: number;
  unitRate?: number;
  unitRateBasis?: string;
  volume?: number;
  lives?: number;
  benefitDetails: BenefitDetails;
}

interface PlanNote {
  note: string;
}

interface GeminiResponse {
  metadata?: GeminiMetadata;
  coverages?: CoverageEntry[];
  planNotes?: PlanNote[];
}

/**
 * Process the JSON response from Gemini API and apply validation/normalization
 * @param json The JSON response from Gemini API
 */
function structureDataWithGemini(fileName: string, category: string, extractedText: string): Promise<GeminiResponse> {
  if (!GEMINI_API_KEY) {
    throw new Error('GEMINI_API_KEY is not set');
  }
  
  // Replace placeholders in the prompt
  const prompt = ENHANCED_GEMINI_PROMPT
    .replace('{{FILE_NAME}}', fileName)
    .replace('{{DOCUMENT_CATEGORY}}', category)
    .replace('{{TEXT_CONTENT}}', extractedText);
  
  const requestData = JSON.stringify({
    contents: [
      {
        parts: [
          { text: prompt }
        ]
      }
    ],
    generationConfig: {
      temperature: 0.2,
      maxOutputTokens: 58192,
      topP: 0.8,
      topK: 40
    }
  });
  
  const options = {
    hostname: 'generativelanguage.googleapis.com',
    path: `/v1beta/models/gemini-2.5-pro-preview-05-06:generateContent?key=${GEMINI_API_KEY}`,
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    }
  };
  
  try {
    const response = httpsRequest(options, requestData);
    
    if (response.error) {
      throw new Error(`Gemini API Error: ${JSON.stringify(response.error)}`);
    }
    
    if (!response.candidates || response.candidates.length === 0) {
      throw new Error('No response from Gemini API');
    }
    
    const textContent = response.candidates[0].content.parts[0]?.text;
    if (!textContent) {
      throw new Error('Empty response from Gemini API');
    }
    
    try {
      // Check if response is wrapped in markdown code block and extract the JSON
      let jsonContent = textContent;
      
      // Handle markdown code block format (```json ... ```)
      if (textContent.startsWith('```json') || textContent.startsWith('```')) {
        const codeBlockStartIndex = textContent.indexOf('{');
        const codeBlockEndIndex = textContent.lastIndexOf('}');
        
        if (codeBlockStartIndex !== -1 && codeBlockEndIndex !== -1 && codeBlockEndIndex > codeBlockStartIndex) {
          jsonContent = textContent.substring(codeBlockStartIndex, codeBlockEndIndex + 1);
        }
      }
      
      // Parse the JSON response
      const parsedJson = JSON.parse(jsonContent);
      
      // Apply validation to the response with enhanced structure checking
      const validatedResponse = validateResponse(parsedJson);
      
      // Ensure metadata has required fields
      if (validatedResponse.metadata && typeof validatedResponse.metadata === 'object') {
        validatedResponse.metadata.fileName = validatedResponse.metadata.fileName || fileName;
        validatedResponse.metadata.fileCategory = validatedResponse.metadata.fileCategory || category;
      }
      
      // Create default coverage entries for common insurance types
      const defaultCoverages = [
        {
          coverageType: 'Basic Life',
          carrierName: validatedResponse.metadata?.carrierName || 'Unknown Carrier',
          planOptionName: validatedResponse.metadata?.planOptionName || 'Default Plan',
          premium: 0,
          monthlyPremium: 0,
          unitRate: 0,
          unitRateBasis: 'per $1,000',
          volume: 0,
          lives: 0,
          benefitDetails: {
            benefitFormula: 'Not specified',
            maximumBenefit: 'Not specified',
            ageReductionSchedule: null,
            terminationAge: null,
            waiver: null,
            conversionOption: null,
            portabilityOption: null,
            acceleratedDeathBenefit: null,
            note: 'Coverage details could not be extracted from document'
          }
        },
        {
          coverageType: 'AD&D',
          carrierName: validatedResponse.metadata?.carrierName || 'Unknown Carrier',
          planOptionName: validatedResponse.metadata?.planOptionName || 'Default Plan',
          premium: 0,
          monthlyPremium: 0,
          unitRate: 0,
          unitRateBasis: 'per $1,000',
          volume: 0,
          lives: 0,
          benefitDetails: {
            benefitFormula: 'Not specified',
            maximumBenefit: 'Not specified',
            note: 'Coverage details could not be extracted from document'
          }
        },
        {
          coverageType: 'LTD',
          carrierName: validatedResponse.metadata?.carrierName || 'Unknown Carrier',
          planOptionName: validatedResponse.metadata?.planOptionName || 'Default Plan',
          premium: 0,
          monthlyPremium: 0,
          unitRate: 0,
          unitRateBasis: 'per $100 covered payroll',
          volume: 0,
          lives: 0,
          benefitDetails: {
            benefitPercentage: null,
            maximumMonthlyBenefit: null,
            eliminationPeriod: null,
            benefitDuration: null,
            ownOccupationPeriod: null,
            definitionOfDisability: null,
            preExistingConditionLimitation: null,
            note: 'Coverage details could not be extracted from document'
          }
        }
      ];
      
      // Add default coverages if there are no valid coverages
      if (!validateCoverages(validatedResponse.coverages)) {
        validatedResponse.coverages = defaultCoverages;
      } else {
        // Normalize existing coverages
        validatedResponse.coverages = validatedResponse.coverages.map(coverage => {
          // Ensure benefitDetails exists
          if (!coverage.benefitDetails || typeof coverage.benefitDetails !== 'object') {
            coverage.benefitDetails = {};
          }
        console.log(`[DEBUG] Coverage validation results: ${validCount} valid, ${invalidCount} invalid items`);
        
        const hasInvalidCoverages = invalidCount > 0;
        
        if (hasInvalidCoverages) {
          console.log('[DEBUG] Found invalid coverages - filtering and repairing...');
          // Filter out invalid coverages
          const filteredCoverages = validatedResponse.coverages
            .filter(coverage => coverage && typeof coverage === 'object');
          
          console.log(`[DEBUG] After filtering non-objects: ${filteredCoverages.length} items remain`);
          
          const repairedCoverages = filteredCoverages.map((coverage, index) => {
            const repaired = {
              coverageType: coverage.coverageType || 'Basic Life',
              carrierName: coverage.carrierName || validatedResponse.metadata?.carrierName || 'Unknown Carrier',
              planOptionName: coverage.planOptionName || validatedResponse.metadata?.planOptionName || 'Default Plan',
              premium: coverage.premium || 0,
              monthlyPremium: coverage.monthlyPremium || 0,
              unitRate: coverage.unitRate || 0,
              unitRateBasis: coverage.unitRateBasis || 'per $1,000',
              volume: coverage.volume || 0,
              lives: coverage.lives || 0,
              benefitDetails: coverage.benefitDetails || { note: 'Limited coverage details could be extracted' }
            };
            console.log(`[DEBUG] Repaired coverage #${index}: ${repaired.coverageType} for ${repaired.carrierName}`);
            return repaired;
          });
          
          validatedResponse.coverages = repairedCoverages;
          console.log(`[DEBUG] After repairing: ${validatedResponse.coverages.length} coverages`);
          
          // If still no valid coverages after filtering, add default
          if (validatedResponse.coverages.length === 0) {
            console.log('[DEBUG] No valid coverages after repair - adding default coverage');
            validatedResponse.coverages.push(defaultCoverage);
          }
        }
        
        console.log('[DEBUG] Final coverages count:', validatedResponse.coverages.length);
        console.log('[DEBUG] ===== Coverage validation complete =====');
      }
      
      // Apply coverage validation and defaults
      // Call ensureCoverageExists but use its results directly in the return statement
      // This avoids reassigning to the const validatedResponse
      return ensureCoverageExists(validatedResponse);
    } catch (jsonError) {
      const errorMessage = jsonError instanceof Error ? jsonError.message : String(jsonError);
      throw new Error(`Failed to parse Gemini response as JSON: ${textContent.substring(0, 200)}...\nError: ${errorMessage}`);
    }
  } catch (error) {
    console.error('Gemini API error:', error);
    // Safely handle error messages regardless of error object structure
    const errorMessage = error instanceof Error ? error.message : 
      typeof error === 'object' && error !== null && 'message' in error ? String(error.message) : 
      String(error);
    throw new Error(`Error calling Gemini API: ${errorMessage}`);
  }
}

export async function POST(req: NextRequest) {
  if (!PDFCO_API_KEY || !GEMINI_API_KEY) {
    return NextResponse.json(
      { error: 'API keys not configured. Please set PDF_UPLOAD_SECRET and GEMINI_API_KEY in environment variables.' },
      { status: 500 }
    );
  }
  
  try {
    // Parse the incoming form data
    const formData = await req.formData();
    const file = formData.get('file') as File | null;
    const category = formData.get('category') as string | null;
    
    // Validate inputs
    if (!file) {
      return NextResponse.json({ error: 'No file provided' }, { status: 400 });
    }
    
    if (file.type !== 'application/pdf') {
      return NextResponse.json({ error: 'Invalid file type, only PDF is accepted' }, { status: 400 });
    }
    
    if (!category) {
      return NextResponse.json({ error: 'No category provided' }, { status: 400 });
    }
    
    console.log('Processing file:', file.name, file.size, file.type);
    console.log('Category:', category);
    
    // Read the file as an ArrayBuffer and convert to Buffer
    const arrayBuffer = await file.arrayBuffer();
    const fileBuffer = Buffer.from(arrayBuffer);
    
    // Step 1: Get a presigned URL from PDF.co
    console.log('Step 1: Getting presigned URL from PDF.co');
    const { presignedUrl, url: uploadedFileUrl } = await getPresignedUrl(file.name);
    
    // Step 2: Upload the file to the presigned URL
    console.log('Step 2: Uploading file to PDF.co');
    await uploadFileToPdfCo(presignedUrl, fileBuffer);
    
    // Step 3: Extract text from the PDF using PDF.co API
    console.log('Step 3: Extracting text from PDF');
    const extractedText = await extractTextFromPdf(uploadedFileUrl);
    console.log(`Extracted text length: ${extractedText.length} characters`);
    
    // Step 4: Process the extracted text with Gemini API
    console.log('Step 4: Processing with Gemini API');
    const structuredData = await structureDataWithGemini(extractedText, file.name, category);
    
    // Return the successful response with all data
    return NextResponse.json({
      message: 'File processed successfully',
      originalFileName: file.name,
      category: category,
      // Add original filename and category to the structured data for frontend use
      data: {
        ...structuredData,
        metadata: {
          ...structuredData.metadata,
          fileName: file.name,
          fileCategory: category
        }
      }
    });
  } catch (error) {
    console.error('Error processing document:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json({ error: 'Processing failed', details: errorMessage }, { status: 500 });
  }
}
